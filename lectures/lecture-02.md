# Лекція 2. Python для веброзробки та FastAPI основи

## Вступ

Сучасна веброзробка вимагає від розробників не лише знання фреймворків, але й глибокого розуміння мови програмування та її можливостей. Python за останні роки став однією з найпопулярніших мов для створення вебзастосунків завдяки своїй простоті, читабельності та потужним бібліотекам. У цій лекції ми розглянемо ключові аспекти Python, які є фундаментальними для роботи з сучасними вебфреймворками, зокрема FastAPI.

FastAPI представляє новий підхід до створення вебзастосунків у Python, поєднуючи високу продуктивність, сучасний синтаксис та автоматичну генерацію документації. Цей фреймворк базується на стандартах Python type hints та асинхронного програмування, що робить код більш надійним та ефективним.

## Python Type Hints та їх роль у FastAPI

### Концепція статичної типізації у динамічній мові

Python традиційно є динамічно типізованою мовою, де тип змінної визначається під час виконання програми. Проте з версії Python 3.5 було введено концепцію type hints, які дозволяють розробникам вказувати очікувані типи даних без зміни динамічної природи мови.

Type hints виконують роль анотацій, які допомагають розробникам та інструментам аналізу коду краще розуміти структуру програми. Вони не впливають на виконання коду у стандартному інтерпретаторі Python, але надають цінну інформацію для статичних аналізаторів, редакторів коду та документації.

### Базові type hints

Розглянемо основні способи використання type hints у Python. Для простих типів даних анотації виглядають інтуїтивно зрозуміло.

```python
def greet(name: str) -> str:
    return f"Привіт, {name}"

age: int = 25
is_active: bool = True
price: float = 99.99
```

У цьому прикладі ми вказуємо, що параметр name має бути рядком, функція повертає рядок, а змінні мають відповідні типи. Це допомагає IDE надавати кращі підказки та виявляти потенційні помилки ще до запуску програми.

### Складні типи з модуля typing

Для складніших структур даних Python надає модуль typing, який містить інструменти для опису колекцій, опціональних значень та інших складних типів.

```python
from typing import List, Dict, Optional, Union, Tuple

users: List[str] = ["Олександр", "Марія", "Іван"]
user_data: Dict[str, int] = {"Олександр": 30, "Марія": 25}
optional_email: Optional[str] = None
identifier: Union[int, str] = "USER_123"
coordinates: Tuple[float, float] = (50.4501, 30.5234)
```

Тип List вказує на список елементів певного типу, Dict описує словник з конкретними типами ключів та значень. Optional позначає, що значення може бути певного типу або None. Union дозволяє вказати кілька можливих типів, а Tuple описує кортеж з фіксованою кількістю елементів визначених типів.

### Type hints у FastAPI

FastAPI революційно використовує type hints для автоматичної валідації вхідних даних, серіалізації відповідей та генерації документації. Фреймворк аналізує анотації типів у функціях обробників запитів та автоматично виконує всі необхідні перевірки.

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Task(BaseModel):
    title: str
    description: str
    completed: bool = False

@app.post("/tasks/")
async def create_task(task: Task) -> Task:
    return task
```

У цьому прикладі FastAPI автоматично розуміє, що очікує отримати JSON з полями title, description та completed, валідує їх типи, створює об'єкт Task та серіалізує його для відповіді. Все це відбувається без написання додаткового коду валідації.

## Асинхронне програмування в Python

### Концепція асинхронності

Асинхронне програмування представляє підхід до виконання операцій, який дозволяє програмі не блокуватися на операціях вводу-виводу. Замість очікування завершення повільної операції, програма може переключитися на виконання іншої роботи, повертаючись до першої операції, коли вона завершиться.

Традиційний синхронний код виконується послідовно. Коли програма робить запит до бази даних або зовнішнього API, вона зупиняється та чекає відповіді. В асинхронному підході програма може ініціювати операцію та продовжити виконання іншого коду, поки операція не завершиться.

### Ключові слова async та await

Python надає два ключових слова для роботи з асинхронним кодом. Ключове слово async визначає асинхронну функцію, яка називається корутиною. Ключове слово await використовується всередині асинхронної функції для очікування результату іншої асинхронної операції.

```python
import asyncio

async def fetch_data():
    print("Починаємо завантаження даних")
    await asyncio.sleep(2)
    print("Дані завантажено")
    return {"data": "важливі дані"}

async def main():
    result = await fetch_data()
    print(f"Отримано: {result}")

asyncio.run(main())
```

У цьому прикладі функція fetch_data є корутиною. Коли ми викликаємо await asyncio.sleep(2), виконання корутини призупиняється на дві секунди, але при цьому не блокується весь процес. Інші корутини можуть виконуватися в цей час.

### Event Loop

Event loop є серцем асинхронного програмування в Python. Це механізм, який керує виконанням асинхронних операцій, відстежує їх стан та переключається між ними.

Event loop працює за принципом циклічної перевірки стану задач. Він постійно перевіряє, чи є корутини, готові до виконання, запускає їх, призупиняє на операціях вводу-виводу та відновлює, коли операції завершуються.

```python
import asyncio

async def task_one():
    print("Задача 1: початок")
    await asyncio.sleep(1)
    print("Задача 1: завершення")

async def task_two():
    print("Задача 2: початок")
    await asyncio.sleep(2)
    print("Задача 2: завершення")

async def main():
    await asyncio.gather(
        task_one(),
        task_two()
    )

asyncio.run(main())
```

Функція asyncio.gather дозволяє запустити кілька корутин одночасно. Event loop буде переключатися між ними, що дозволить обом задачам виконуватися паралельно.

### Корутини та Tasks

Корутина є спеціальним типом функції, яка може призупиняти своє виконання та передавати контроль іншим корутинам. Task є обгорткою навколо корутини, яка планує її виконання в event loop.

```python
import asyncio

async def process_data(data_id: int):
    print(f"Обробка даних {data_id}")
    await asyncio.sleep(1)
    return f"Результат {data_id}"

async def main():
    task1 = asyncio.create_task(process_data(1))
    task2 = asyncio.create_task(process_data(2))
    task3 = asyncio.create_task(process_data(3))

    results = await asyncio.gather(task1, task2, task3)
    print(f"Всі результати: {results}")

asyncio.run(main())
```

Використання create_task дозволяє запланувати виконання корутини в event loop, не чекаючи на її завершення одразу. Це дає змогу створити кілька tasks та потім дочекатися їх всіх разом за допомогою gather.

### Асинхронні контекстні менеджери

Python підтримує асинхронні версії контекстних менеджерів, які корисні для роботи з ресурсами в асинхронному коді.

```python
class AsyncResource:
    async def __aenter__(self):
        print("Відкриття ресурсу")
        await asyncio.sleep(1)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("Закриття ресурсу")
        await asyncio.sleep(1)

async def use_resource():
    async with AsyncResource() as resource:
        print("Використання ресурсу")
```

Асинхронні контекстні менеджери використовують методи __aenter__ та __aexit__, які є корутинами. Це дозволяє виконувати асинхронні операції при відкритті та закритті ресурсів.

## Введення у FastAPI

### Чому FastAPI

FastAPI з'явився як відповідь на потребу в сучасному, швидкому та простому у використанні вебфреймворку для Python. Його створив Sebastián Ramírez з метою об'єднати кращі практики розробки API з високою продуктивністю та зручністю розробки.

Ключові переваги FastAPI включають автоматичну валідацію даних на основі type hints, автоматичну генерацію інтерактивної документації, високу продуктивність завдяки асинхронності та підтримку сучасних стандартів OpenAPI та JSON Schema.

FastAPI базується на двох потужних бібліотеках: Starlette для вебфункціональності та Pydantic для валідації даних. Це робить фреймворк швидким та надійним, оскільки обидві бібліотеки є добре протестованими та оптимізованими.

### Порівняння з Flask та Django

Flask є мікрофреймворком, який надає базову функціональність для створення вебзастосунків. Він простий у вивченні та гнучкий, але не має вбудованої підтримки асинхронності та автоматичної валідації. Для створення API з Flask потрібно додавати додаткові бібліотеки та писати більше коду для валідації.

Django є повноцінним фреймворком з великою кількістю вбудованих можливостей, включаючи ORM, адміністративну панель та систему автентифікації. Проте Django традиційно орієнтований на створення традиційних вебзастосунків з серверним рендерингом, а не на API. Django REST Framework додає функціональність для API, але архітектура залишається складнішою порівняно з FastAPI.

FastAPI фокусується виключно на створенні API, використовує сучасні можливості Python та надає продуктивність, порівнянну з Node.js та Go. Автоматична генерація документації та валідація даних значно прискорюють розробку та зменшують кількість помилок.

### Встановлення та налаштування

Для початку роботи з FastAPI потрібно встановити сам фреймворк та сервер ASGI, який буде виконувати застосунок. Uvicorn є рекомендованим сервером для FastAPI завдяки своїй продуктивності та простоті використання.

```bash
pip install fastapi uvicorn[standard]
```

Параметр standard у uvicorn додає додаткові залежності для покращення продуктивності, включаючи підтримку веб-сокетів та HTTP/2.

## Перший FastAPI застосунок

### Мінімальний приклад

Найпростіший FastAPI застосунок демонструє основні концепції фреймворку та показує, наскільки мало коду потрібно для створення функціонального API.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Вітаємо у FastAPI"}

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}
```

У цьому прикладі створюється екземпляр FastAPI застосунку. Декоратор @app.get визначає обробник для GET-запитів на вказаний шлях. Функція read_item демонструє використання path parameter, який автоматично перетворюється на тип int згідно з type hint.

### Структура проєкту

Для реальних застосунків рекомендується організовувати код у структуровану систему файлів та папок.

```
my_project/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── models.py
│   ├── schemas.py
│   └── routers/
│       ├── __init__.py
│       └── tasks.py
├── tests/
│   └── __init__.py
├── requirements.txt
└── README.md
```

Файл main.py містить створення застосунку та підключення роутерів. Файл models.py містить моделі для роботи з базою даних. Файл schemas.py містить Pydantic схеми для валідації та серіалізації. Папка routers містить окремі модулі з ендпоінтами для різних сутностей.

```python
# app/main.py
from fastapi import FastAPI
from app.routers import tasks

app = FastAPI(title="Task Manager API")

app.include_router(tasks.router, prefix="/tasks", tags=["tasks"])

@app.get("/")
async def root():
    return {"message": "Task Manager API"}
```

### Запуск застосунку

Для запуску FastAPI застосунку використовується команда uvicorn з вказанням модуля та назви змінної застосунку.

```bash
uvicorn app.main:app --reload
```

Параметр --reload вмикає автоматичне перезавантаження сервера при зміні файлів, що зручно під час розробки. Після запуску застосунок буде доступний за адресою http://localhost:8000.

## Pydantic Models для валідації та серіалізації

### Концепція Pydantic

Pydantic є бібліотекою для валідації даних та управління налаштуваннями з використанням type hints. FastAPI використовує Pydantic для автоматичної валідації вхідних даних та серіалізації відповідей.

Основною концепцією Pydantic є створення класів, які наслідуються від BaseModel та визначають структуру даних за допомогою class attributes з type hints.

### Базова модель

Створення Pydantic моделі відбувається шляхом наслідування від BaseModel та визначення полів з їх типами.

```python
from pydantic import BaseModel
from typing import Optional

class Task(BaseModel):
    id: Optional[int] = None
    title: str
    description: str
    completed: bool = False
```

У цій моделі поле id є опціональним та має значення за замовчуванням None. Поля title та description є обов'язковими рядками. Поле completed має значення за замовчуванням False.

### Валідація даних

Pydantic автоматично валідує дані при створенні екземпляра моделі. Якщо дані не відповідають визначеним типам, виникає помилка валідації.

```python
try:
    task = Task(title="Тестове завдання", description="Опис")
    print(task)
except Exception as e:
    print(f"Помилка валідації: {e}")
```

Коли дані коректні, створюється екземпляр Task. Якщо тип даних невірний, Pydantic генерує детальну помилку з описом проблеми.

### Додаткові можливості валідації

Pydantic надає багато інструментів для складнішої валідації, включаючи Field для додаткових обмежень та validator для кастомної логіки.

```python
from pydantic import BaseModel, Field, validator

class Task(BaseModel):
    title: str = Field(..., min_length=3, max_length=100)
    description: str
    priority: int = Field(default=1, ge=1, le=5)

    @validator('title')
    def title_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Назва не може бути порожньою')
        return v.strip()
```

Field дозволяє встановити обмеження на довжину рядків та діапазон чисел. Декоратор validator дозволяє створювати кастомну логіку валідації для конкретних полів.

## Path Parameters, Query Parameters та Request Body

### Path Parameters

Path parameters є частиною URL шляху та використовуються для ідентифікації конкретного ресурсу.

```python
@app.get("/tasks/{task_id}")
async def get_task(task_id: int):
    return {"task_id": task_id, "title": "Приклад завдання"}
```

FastAPI автоматично витягує task_id з URL та перетворює його на тип int. Якщо значення не може бути перетворено на int, FastAPI повертає помилку валідації.

### Query Parameters

Query parameters передаються в URL після знаку питання та використовуються для фільтрації або налаштування запиту.

```python
from typing import Optional

@app.get("/tasks/")
async def list_tasks(skip: int = 0, limit: int = 10, completed: Optional[bool] = None):
    return {
        "skip": skip,
        "limit": limit,
        "completed": completed
    }
```

У цьому прикладі параметри skip та limit мають значення за замовчуванням, тому їх можна не передавати. Параметр completed є опціональним та може бути відсутнім у запиті.

### Request Body

Request body використовується для передачі складних даних у запитах POST, PUT та PATCH. FastAPI автоматично парсить JSON та валідує його згідно з Pydantic моделлю.

```python
@app.post("/tasks/")
async def create_task(task: Task):
    return task
```

FastAPI автоматично читає тіло запиту, парсить JSON, валідує дані згідно з моделлю Task та передає валідний об'єкт у функцію. Якщо валідація не вдається, повертається детальна помилка.

### Комбінування параметрів

У реальних застосунках часто потрібно використовувати всі типи параметрів одночасно.

```python
@app.put("/tasks/{task_id}")
async def update_task(
    task_id: int,
    task: Task,
    force: bool = False
):
    return {
        "task_id": task_id,
        "task": task,
        "force": force
    }
```

У цьому прикладі task_id є path parameter, task передається в request body, а force є query parameter. FastAPI автоматично розпізнає тип кожного параметра на основі його позиції та type hint.

## Автоматична документація

### Swagger UI

FastAPI автоматично генерує інтерактивну документацію на основі OpenAPI стандарту. Swagger UI доступний за адресою /docs та дозволяє тестувати API безпосередньо з браузера.

```python
app = FastAPI(
    title="Task Manager API",
    description="API для управління завданнями",
    version="1.0.0"
)
```

Додаткові параметри при створенні FastAPI застосунку покращують документацію, додаючи назву, опис та версію API.

### ReDoc

Альтернативна документація доступна за адресою /redoc та надає інший інтерфейс для перегляду API документації.

### Додавання описів

Для покращення документації можна додавати описи до ендпоінтів, параметрів та моделей.

```python
@app.post(
    "/tasks/",
    response_model=Task,
    summary="Створити нове завдання",
    description="Створює нове завдання з вказаними параметрами",
    response_description="Створене завдання"
)
async def create_task(task: Task):
    return task
```

Параметри summary та description додають інформацію до документації. Параметр response_model вказує, яка модель буде повернута, що також відображається в документації.

## Висновки

У цій лекції ми розглянули фундаментальні концепції, необхідні для роботи з FastAPI. Type hints є основою для автоматичної валідації та генерації документації. Асинхронне програмування дозволяє створювати високопродуктивні застосунки, які ефективно обробляють велику кількість одночасних запитів.

FastAPI представляє сучасний підхід до створення API, що поєднує простоту розробки з високою продуктивністю. Pydantic models надають потужні інструменти для валідації даних без необхідності писати багато коду вручну. Автоматична генерація документації значно спрощує процес розробки та підтримки API.

Розуміння цих концепцій є критично важливим для ефективної роботи з FastAPI та створення якісних вебзастосунків. Наступні заняття будуть присвячені більш глибокому вивченню можливостей фреймворку, включаючи роботу з базами даних, автентифікацію та тестування.
