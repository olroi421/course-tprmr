# Лекція 3. Робота з базами даних у FastAPI

## Вступ

Робота з базами даних є критично важливою складовою будь-якого серйозного вебдодатку. У цій лекції ми розглянемо, як ефективно інтегрувати реляційні бази даних у FastAPI додатки, використовуючи сучасні підходи та найкращі практики. Особливу увагу приділимо асинхронній роботі з базами даних, що дозволяє максимально ефективно використовувати ресурси сервера.

## SQLAlchemy: Core vs ORM

SQLAlchemy є найпопулярнішою бібліотекою для роботи з реляційними базами даних у Python екосистемі. Вона пропонує два основних підходи до взаємодії з базою даних.

### SQLAlchemy Core

SQLAlchemy Core надає низькорівневий API для роботи з базою даних. Цей підхід ближчий до написання чистого SQL, але з додатковими можливостями Python. Core дозволяє будувати SQL запити програмно, використовуючи Python вирази, що потім транслюються у відповідні SQL команди.

Основні переваги Core полягають у повному контролі над генерованими SQL запитами та високій продуктивності. Розробник явно бачить, які саме операції виконуються на рівні бази даних, що спрощує оптимізацію та налагодження. Core особливо корисний для складних аналітичних запитів або випадків, коли потрібна максимальна продуктивність.

Однак Core вимагає більше коду для виконання стандартних операцій та не надає автоматичного відображення між об'єктами Python та таблицями бази даних. Розробник повинен вручну керувати перетворенням даних між цими двома представленнями.

### SQLAlchemy ORM

Object-Relational Mapping (ORM) надає вищий рівень абстракції, де таблиці бази даних представлені як класи Python, а рядки таблиць як екземпляри цих класів. ORM автоматично керує відображенням між об'єктною моделлю застосунку та реляційною структурою бази даних.

Головна перевага ORM полягає у природності роботи з даними через об'єкти Python. Розробник оперує звичними класами та методами, не замислюючись про деталі SQL синтаксису. ORM автоматично відстежує зміни об'єктів та генерує відповідні SQL команди для синхронізації стану з базою даних. Це значно прискорює розробку типових CRUD операцій та зменшує кількість помилок.

ORM також надає потужні можливості для роботи зі зв'язками між таблицями. Наприклад, можна легко завантажити пов'язані об'єкти, використовуючи відношення один-до-багатьох або багато-до-багатьох, не турбуючись про написання JOIN запитів вручну.

Недоліком ORM може бути менш передбачувана генерація SQL запитів, особливо для складних операцій. У деяких випадках автоматично згенерований SQL може бути неоптимальним, що вимагає додаткових налаштувань або переходу до використання Core.

### Вибір між Core та ORM

Для більшості застосунків рекомендується використовувати ORM як основний підхід, оскільки він значно підвищує продуктивність розробки та читабельність коду. Водночас, SQLAlchemy дозволяє комбінувати обидва підходи у одному проєкті. Для стандартних CRUD операцій можна використовувати ORM, а для складних аналітичних запитів чи операцій, що вимагають високої продуктивності, переходити до Core.

## Async SQLAlchemy

Сучасні версії SQLAlchemy (починаючи з версії 1.4 та повністю у версії 2.0) надають повноцінну підтримку асинхронного програмування. Це критично важливо для FastAPI, оскільки асинхронність є ключовою перевагою цього фреймворку.

### AsyncEngine та AsyncSession

AsyncEngine є асинхронним аналогом традиційного Engine у SQLAlchemy. Він керує пулом з'єднань з базою даних та надає можливість створювати асинхронні сесії для виконання запитів. Створення AsyncEngine відбувається через функцію create_async_engine, яка приймає URL підключення до бази даних.

AsyncSession представляє одиницю роботи з базою даних у асинхронному контексті. Через сесію виконуються всі операції читання та запису даних. Важливою особливістю AsyncSession є необхідність використання await для всіх операцій з базою даних, що дозволяє іншим корутинам виконуватися під час очікування відповіді від бази даних.

### Конфігурація асинхронного підключення

При налаштуванні асинхронного підключення до PostgreSQL використовується asyncpg драйвер, який є одним з найшвидших асинхронних драйверів для PostgreSQL. URL підключення має формат postgresql+asyncpg://, що вказує SQLAlchemy використовувати саме цей драйвер.

Важливим аспектом конфігурації є налаштування пулу з'єднань. Пул з'єднань підтримує певну кількість активних підключень до бази даних, що дозволяє уникати накладних витрат на створення нових з'єднань для кожного запиту. Параметри pool_size та max_overflow визначають мінімальну та максимальну кількість з'єднань у пулі.

### Dependency Injection для сесій

FastAPI надає елегантний механізм впровадження залежностей (Dependency Injection), який ідеально підходить для керування сесіями бази даних. Створюється функція-генератор, що відкриває нову сесію, надає її обробнику запиту, а після завершення обробки автоматично закриває сесію. Це гарантує, що кожен запит отримує свою власну сесію, та що сесія коректно закривається навіть у випадку помилок.

Використання Depends у FastAPI дозволяє автоматично впроваджувати сесію у функції-обробники. Фреймворк сам викликає функцію-генератор, передає створену сесію у обробник, а після завершення обробки виконує код очищення у блоці finally генератора.

## Alembic для міграцій

Alembic є інструментом для керування міграціями схеми бази даних. Міграція представляє собою версіонований набір змін у структурі бази даних, що дозволяє безпечно еволюціонувати схему даних разом з розвитком застосунку.

### Концепція міграцій

Міграції вирішують фундаментальну проблему версіонування схеми бази даних. Коли застосунок розвивається, його модель даних змінюється: додаються нові таблиці, змінюються існуючі колонки, створюються нові індекси. Міграції дозволяють застосовувати ці зміни контрольовано та відтворювано.

Кожна міграція має унікальний ідентифікатор та містить два набори операцій: upgrade для застосування змін та downgrade для їх відкату. Це дозволяє не тільки рухатися вперед у розвитку схеми, але й повертатися до попередніх версій у разі необхідності.

Alembic відстежує, які міграції вже застосовані до конкретної бази даних, зберігаючи цю інформацію у спеціальній службовій таблиці. Це дозволяє застосовувати тільки нові міграції та уникати повторного виконання вже застосованих змін.

### Ініціалізація Alembic

Початкове налаштування Alembic починається з виконання команди alembic init, яка створює необхідну структуру директорій та конфігураційні файли. Створюється директорія alembic з файлами міграцій та файл alembic.ini з налаштуваннями.

Основний конфігураційний файл env.py у директорії alembic потребує налаштування для роботи з асинхронним SQLAlchemy. У цьому файлі визначається, як Alembic підключається до бази даних та які моделі використовувати для автогенерації міграцій.

### Автоматична генерація міграцій

Однією з найпотужніших можливостей Alembic є автоматична генерація міграцій на основі змін у моделях SQLAlchemy. Alembic порівнює поточний стан моделей з станом бази даних та генерує код міграції, що містить необхідні операції для синхронізації.

Команда alembic revision --autogenerate аналізує моделі та створює новий файл міграції з операціями upgrade та downgrade. Розробник повинен переглянути згенерований код та за необхідності відкоригувати його, оскільки автоматична генерація не завжди ідеально відображає задум розробника.

### Застосування міграцій

Після створення міграцій вони застосовуються до бази даних командою alembic upgrade head, де head вказує на найновішу версію. Alembic виконує всі міграції в правильному порядку, пропускаючи вже застосовані.

Для відкату змін використовується команда alembic downgrade з вказівкою цільової версії. Це може бути корисно під час розробки або у випадку виявлення проблем після розгортання нової версії.

## Repository Pattern

Repository Pattern є архітектурним шаблоном, що забезпечує абстракцію над логікою доступу до даних. Репозиторій інкапсулює всі операції з конкретною сутністю, надаючи чистий інтерфейс для роботи з даними.

### Переваги Repository Pattern

Основна перевага репозиторію полягає у відокремленні бізнес-логіки від деталей доступу до даних. Код, що використовує репозиторій, не знає про SQLAlchemy, SQL запити чи структуру бази даних. Він оперує методами на кшталт get_by_id, create або update, що мають чіткий бізнес-сенс.

Репозиторії спрощують тестування, оскільки їх легко замінити на mock об'єкти під час написання unit тестів. Бізнес-логіка може бути протестована ізольовано від бази даних, що прискорює виконання тестів та робить їх більш надійними.

Централізація логіки доступу до даних у репозиторіях зменшує дублювання коду. Типові операції, такі як пагінація, фільтрація чи сортування, реалізуються один раз у репозиторії та використовуються у різних частинах застосунку.

### Реалізація базового репозиторію

Типовий репозиторій містить методи для основних CRUD операцій. Метод get_by_id отримує сутність за її ідентифікатором, get_all повертає список всіх сутностей з можливістю пагінації, create створює нову сутність, update оновлює існуючу, а delete видаляє сутність.

Кожен метод репозиторію є асинхронним та приймає AsyncSession як параметр. Це дозволяє репозиторію працювати у асинхронному контексті FastAPI та ефективно використовувати ресурси сервера.

Репозиторії можуть містити не тільки базові CRUD операції, але й специфічні для сутності методи. Наприклад, репозиторій користувачів може мати метод get_by_email для пошуку користувача за електронною поштою, або метод get_active_users для отримання тільки активних користувачів.

### Узагальнені репозиторії

Для уникнення дублювання коду можна створити базовий узагальнений репозиторій, який реалізує стандартні CRUD операції. Конкретні репозиторії наслідують цей базовий клас та додають специфічну для своєї сутності логіку.

Узагальнений репозиторій використовує Python generic types для визначення типу сутності, з якою він працює. Це забезпечує типобезпеку та дозволяє IDE надавати автодоповнення при роботі з репозиторієм.

## Database Session Management

Правильне керування сесіями бази даних є критично важливим для стабільності та продуктивності застосунку. Неправильне використання сесій може призводити до витоків з'єднань, deadlock'ів та інших проблем.

### Життєвий цикл сесії

Сесія у SQLAlchemy представляє одиницю роботи з базою даних. Вона відкривається на початку обробки запиту, використовується для виконання необхідних операцій, а після завершення обробки закривається та повертає з'єднання назад у пул.

У FastAPI застосунках зручно використовувати pattern сесія-на-запит, де кожен HTTP запит отримує свою власну сесію. Це забезпечує ізоляцію між запитами та спрощує розуміння потоку даних у застосунку.

Важливо завжди закривати сесії після використання, навіть у випадку помилок. Використання контекстних менеджерів або генераторів з yield гарантує, що код очищення виконається у будь-якому випадку.

### Транзакції

Сесія автоматично керує транзакціями. Коли викликається метод commit, всі зміни, внесені через сесію, фіксуються у базі даних атомарно. Якщо виникає помилка до commit, можна викликати rollback для скасування всіх змін.

FastAPI дозволяє використовувати декоратори та middleware для автоматичного керування транзакціями. Наприклад, можна створити middleware, який автоматично робить commit після успішної обробки запиту або rollback у випадку помилки.

### Lazy Loading vs Eager Loading

Lazy loading означає, що пов'язані об'єкти завантажуються з бази даних тільки тоді, коли до них звертаються. Це може призводити до проблеми N+1 запитів, коли для отримання списку об'єктів з їх зв'язками виконується велика кількість окремих запитів.

Eager loading вирішує цю проблему шляхом завантаження пов'язаних об'єктів одразу разом з основними об'єктами. SQLAlchemy надає декілька стратегій eager loading, таких як joinedload та selectinload, що дозволяють оптимізувати кількість запитів до бази даних.

## Connection Pooling

Connection pooling є технікою, що дозволяє повторно використовувати існуючі з'єднання з базою даних замість створення нових для кожного запиту. Це значно покращує продуктивність, оскільки встановлення з'єднання є відносно дорогою операцією.

### Налаштування пулу з'єднань

SQLAlchemy автоматично створює пул з'єднань при ініціалізації engine. Параметр pool_size визначає кількість з'єднань, що постійно підтримуються у пулі. Параметр max_overflow визначає максимальну кількість додаткових з'єднань, що можуть бути створені понад pool_size у моменти високого навантаження.

Правильне налаштування розміру пулу залежить від характеристик застосунку та бази даних. Занадто малий пул може призводити до очікування на доступні з'єднання під час високого навантаження. Занадто великий пул може перевантажити базу даних та витрачати ресурси даремно.

### Моніторинг пулу з'єднань

Важливо відстежувати використання пулу з'єднань у продакшені. SQLAlchemy надає події та методи для моніторингу стану пулу, такі як кількість активних з'єднань, кількість з'єднань в очікуванні та кількість таймаутів.

Метрики пулу з'єднань можна інтегрувати з системами моніторингу на кшталт Prometheus або Grafana для візуалізації та алертингу при виникненні проблем.

## Оптимізація запитів

Продуктивність роботи з базою даних часто є вузьким місцем у вебзастосунках. Правильна оптимізація запитів може значно покращити швидкість відгуку застосунку.

### Використання індексів

Індекси є основним інструментом оптимізації продуктивності запитів. Індекс дозволяє базі даних швидко знаходити рядки за певними колонками без необхідності сканування всієї таблиці. Особливо важливо створювати індекси для колонок, що часто використовуються у WHERE умовах, JOIN операціях або ORDER BY сортуваннях.

SQLAlchemy дозволяє визначати індекси безпосередньо у моделях через параметр index або через створення явних об'єктів Index. Alembic автоматично генерує міграції для створення та видалення індексів разом з іншими змінами схеми.

### Пагінація та обмеження результатів

Завжди важливо обмежувати кількість повертаних рядків при виконанні запитів, що потенційно можуть повернути велику кількість даних. Методи limit та offset у SQLAlchemy дозволяють реалізувати пагінацію результатів.

Однак використання offset для глибокої пагінації може бути неефективним, оскільки база даних все одно повинна обробити всі попередні рядки. Для великих датасетів кращим підходом є cursor-based pagination, що використовує унікальний ідентифікатор останнього завантаженого елемента замість числового зсуву.

### Вибіркове завантаження колонок

У випадках, коли потрібна тільки частина інформації з таблиці, можна використовувати вибіркове завантаження колонок замість завантаження всього об'єкта. Це зменшує обсяг даних, що передаються між базою даних та застосунком, та прискорює виконання запитів.

SQLAlchemy дозволяє вказувати конкретні колонки у запиті через метод options з load_only або defer для відкладеного завантаження певних колонок.

## Транзакції та ACID

ACID є акронімом, що описує властивості транзакцій у реляційних базах даних: Atomicity (атомарність), Consistency (узгодженість), Isolation (ізоляція) та Durability (довговічність).

### Атомарність

Атомарність означає, що транзакція виконується повністю або не виконується взагалі. Якщо будь-яка частина транзакції зазнає невдачі, всі зміни відкочуються, залишаючи базу даних у початковому стані. Це критично важливо для підтримки цілісності даних.

У SQLAlchemy транзакція автоматично починається при першій операції з базою даних через сесію. Виклик commit фіксує всі зміни атомарно, а виклик rollback скасовує їх.

### Узгодженість

Узгодженість гарантує, що транзакція переводить базу даних з одного валідного стану в інший валідний стан. Всі обмеження цілісності, такі як зовнішні ключі, унікальність або check constraints, перевіряються та забезпечуються.

### Ізоляція

Ізоляція визначає, як зміни, внесені однією транзакцією, видимі для інших паралельних транзакцій. Різні рівні ізоляції надають різний баланс між узгодженістю даних та продуктивністю.

PostgreSQL підтримує чотири рівні ізоляції: Read Uncommitted, Read Committed (за замовчуванням), Repeatable Read та Serializable. Вищі рівні ізоляції надають сильніші гарантії узгодженості, але можуть знижувати продуктивність через збільшення блокувань.

### Довговічність

Довговічність гарантує, що після успішного commit транзакції зміни залишаються у базі даних навіть у випадку збою системи. Це досягається через механізми журналювання та checkpointing у базі даних.

## Висновки

Робота з базами даних у FastAPI через асинхронний SQLAlchemy надає потужний та ефективний спосіб керування даними застосунку. Використання ORM спрощує розробку та підтримку коду, а Alembic забезпечує контрольоване версіонування схеми бази даних. Repository Pattern надає чисту абстракцію над доступом до даних, що покращує архітектуру застосунку та спрощує тестування. Правильне керування сесіями, налаштування connection pooling та оптимізація запитів є ключовими факторами для досягнення високої продуктивності та стабільності застосунку.
