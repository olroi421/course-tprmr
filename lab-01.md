# Лабораторна робота 1. Проєктування REST API

**Дисципліна:** Технології проектування та розробки мережевих ресурсів
**Тема:** Проєктування REST API для системи управління задачами
**Тривалість:** 2 години

---

## Мета роботи

Навчитися проєктувати REST API, застосовуючи принципи resource-oriented design, правильно використовуючи HTTP методи та статус-коди. Студенти мають продемонструвати базове розуміння принципів REST.

---

## Теоретичні відомості

### Принципи REST API

REST API проєктується навколо концепції ресурсів:

- Кожен ресурс має унікальний URI.
- Операції виконуються через HTTP методи.
- Використовуються стандартні статус-коди.

### HTTP методи

- **GET** - отримання ресурсу (безпечний, ідемпотентний).
- **POST** - створення ресурсу (не ідемпотентний).
- **PUT** - повне оновлення ресурсу (ідемпотентний).
- **PATCH** - часткове оновлення ресурсу.
- **DELETE** - видалення ресурсу (ідемпотентний).

### HTTP статус-коди

**2xx Успішні відповіді:**

- 200 OK - успішний GET, PUT, PATCH.
- 201 Created - успішний POST.
- 204 No Content - успішний DELETE.

**4xx Помилки клієнта:**

- 400 Bad Request - некоректні дані.
- 401 Unauthorized - потрібна автентифікація.
- 404 Not Found - ресурс не існує.
- 409 Conflict - конфлікт стану.

**5xx Помилки сервера:**

- 500 Internal Server Error - помилка сервера.

### Об'єкти передачі даних (DTO)

DTO відокремлюють внутрішню модель від API:

- **CreateDTO** - дані для створення (без id).
- **UpdateDTO** - дані для оновлення (необов'язкові поля).
- **ResponseDTO** - дані у відповіді (включає readonly поля).

---

## Завдання

Спроєктуйте REST API для простої системи управління задачами.

### Функціональні вимоги

**Задачі (Tasks):**

- Створення задачі.
- Перегляд списку задач.
- Перегляд конкретної задачі.
- Оновлення задачі.
- Видалення задачі.
- Фільтрація за статусом.

**Користувачі (Users):**

- Перегляд списку користувачів.
- Перегляд конкретного користувача.

### Атрибути

**Task:**

- Назва (обов'язково, 3-200 символів).
- Опис (необов'язково, максимум 1000 символів).
- Статус: todo, in_progress, done.
- Пріоритет: low, medium, high.
- Дата створення (автоматично).

**User:**

- Ім'я.
- Email.

---

## Хід роботи

### Частина 1. Аналіз предметної області

Проаналізуйте предметну область та визначте основні ресурси системи.

**Завдання:**

1. Заповніть таблицю ресурсів та їхніх атрибутів:

| Ресурс | Основні атрибути | Типи даних |
|--------|------------------|------------|
| Task | ... | ... |
| User | ... | ... |

2. Вкажіть, які атрибути є обов'язковими, а які необов'язковими.

3. Визначте, які атрибути мають генеруватися автоматично сервером.

---

### Частина 2. Проєктування API endpoints

Спроєктуйте API endpoints для всіх необхідних операцій.

**Завдання:**

1. Створіть таблицю API endpoints (мінімум 7):

| HTTP метод | Шлях URI | Опис | Статус-коди (успіх та помилки) |
|------------|----------|------|--------------------------------|
| ... | ... | ... | ... |

2. Додайте приклади URL для фільтрації задач:
   - За статусом
   - За пріоритетом
   - Комбіновану фільтрацію (статус + пріоритет)

---

### Частина 3. Структури даних

Розробіть структури JSON для всіх операцій.

**Завдання:**

1. **Відповідь Task (ResponseDTO):**
   - Створіть JSON структуру для відповіді при отриманні задачі.
   - Включіть всі атрибути, включно з автоматично згенерованими.
   - Використайте реалістичні приклади даних.

2. **CreateTaskDTO:**
   - Які поля має надсилати клієнт для створення задачі?
   - Які поля є обов'язковими?
   - Які значення за замовчуванням?

3. **UpdateTaskDTO:**
   - Чим він відрізняється від CreateTaskDTO?
   - Чому всі поля необов'язкові?

4. **Відповідь User (ResponseDTO):**
   - Створіть JSON структуру для користувача.

5. **Список задач з посторінковою навігацією:**
   - Як повертати список задач?
   - Які метадані додати для pagination?
   - Створіть приклад відповіді з мінімум 2 задачами.

**Підказка:** Думайте про реальне використання API. Що клієнт має відправити? Що сервер має повернути?

---

### Частина 4. Обробка помилок

Розробіть уніфіковану систему обробки помилок.

**Завдання:**

1. Створіть стандартну структуру JSON для помилок, яка включає:
   - Код помилки
   - Зрозуміле повідомлення
   - Додаткову інформацію (опціонально)
   - Мітку часу

2. Визначте коди помилок для кожної ситуації:

| HTTP статус | Код помилки | Коли виникає | Приклад повідомлення |
|-------------|-------------|--------------|----------------------|
| 400 | ... | ... | ... |
| 401 | ... | ... | ... |
| 404 | ... | ... | ... |
| 409 | ... | ... | ... |
| 500 | ... | ... | ... |

3. Створіть два приклади:
   - Помилка валідації (коли клієнт надіслав некоректні дані)
   - Помилка "ресурс не знайдено"

---

## Форма здачі

Створіть файл `lab-01-[прізвище].md` з наступною структурою:

```markdown
# Лабораторна робота 1: Проєктування REST API

**ПІБ:** [Ваше ПІБ]
**Група:** [Група]
**Дата:** [Дата]

## 1. Аналіз предметної області

### Таблиця ресурсів

| Ресурс | Основні атрибути | Типи даних |
|--------|------------------|------------|
| ... | ... | ... |

### Обов'язкові та необов'язкові поля

[Ваш опис]

### Автоматично згенеровані поля

[Ваш опис]

## 2. Кінцеві точки API

### Таблиця endpoints

| HTTP метод | Шлях URI | Опис | Статус-коди |
|------------|----------|------|-------------|
| ... | ... | ... | ... |

### Приклади фільтрації

[Ваші приклади URL]

### Обґрунтування вибору

[Чому обрали такі шляхи та статус-коди]

### Відповіді на питання

1. [Відповідь про 404]
2. [Відповідь про 204]
3. [Відповідь про PUT vs PATCH]

## 3. Структури даних

### Відповідь Task (ResponseDTO)
\```json
{...}
\```

### CreateTaskDTO
\```json
{...}
\```

**Пояснення полів:** [які поля, чому, значення за замовчуванням]

### UpdateTaskDTO
\```json
{...}
\```

**Відмінності від CreateDTO:** [ваше пояснення]

### Відповідь User
\```json
{...}
\```

### Список задач
\```json
{...}
\```

## 4. Обробка помилок

### Стандартна структура помилки
\```json
{...}
\```

### Таблиця кодів помилок

| HTTP статус | Код помилки | Коли виникає | Приклад |
|-------------|-------------|--------------|---------|
| ... | ... | ... | ... |

### Приклад 1: Помилка валідації
\```json
{...}
\```

### Приклад 2: Ресурс не знайдено
\```json
{...}
\```


```

**Здача:** Moodle курс дисципліни

---

## Критерії оцінювання

Максимальна оцінка: **4 бали** (+ **1 бонусний**)

| Критерій | Бали | Що оцінюється |
|----------|------|---------------|
| Аналіз предметної області | 0.5 | Правильність визначення ресурсів, атрибутів та типів |
| Кінцеві точки API | 1.5 | Правильні HTTP методи, URI, статус-коди, обґрунтування |
| Структури даних | 1.0 | Коректні JSON, різні DTO, реалістичні дані |
| Обробка помилок | 0.5 | Стандартна структура, коди помилок, приклади |
| Відповіді та обґрунтування | 0.5 | Розуміння REST принципів, якість пояснень |

### Деталізація оцінювання:

**0.5 бала за аналіз:**

- ✅ Всі ресурси визначені
- ✅ Атрибути з типами даних
- ✅ Розділення обов'язкових/необов'язкових

**1.5 бала за кінцеві точки:**

- ✅ Мінімум 7 endpoints
- ✅ Правильні HTTP методи
- ✅ RESTful URI (іменники, множина)
- ✅ Всі релевантні статус-коди
- ✅ Приклади фільтрації
- ✅ Обґрунтування рішень

**1.0 бал за структури:**

- ✅ Task ResponseDTO з реалістичними даними
- ✅ CreateTaskDTO (відрізняється від Response)
- ✅ UpdateTaskDTO (відрізняється від Create)
- ✅ User ResponseDTO
- ✅ Структура списку з metadata
- ✅ Пояснення різниць між DTO

**0.5 бала за помилки:**

- ✅ Стандартна структура
- ✅ Мінімум 5 кодів помилок
- ✅ 2 детальні приклади
- ✅ Обґрунтування підходу

**0.5 бала за розуміння:**

- ✅ Відповіді на всі питання
- ✅ Обґрунтування вибору рішень
- ✅ Демонстрація розуміння REST

---

## Контрольні питання

1. У чому різниця між PUT та PATCH? Коли використовувати кожен?
2. Чому важливо розділяти CreateDTO і UpdateDTO?
3. Який статус-код для успішного DELETE: 200 чи 204? Чому?
4. Як правильно називати URI: іменники чи дієслова? Чому?
5. Що означає "ідемпотентний" метод? Наведіть приклади.
6. Коли використовувати 404 замість 400? У чому різниця?
7. Чому важлива стандартизована структура помилок?
8. Що таке DTO і навіщо його використовувати?

---

## Поширені помилки

❌ **Не робіть так:**

1. **Дієслова в URI:**
   ```
   ❌ POST /api/createTask
   ❌ GET /api/getTasks
   ✅ POST /api/tasks
   ✅ GET /api/tasks
   ```

2. **Неправильні статус-коди:**
   ```
   ❌ 200 OK при створенні
   ✅ 201 Created

   ❌ 200 OK при видаленні
   ✅ 204 No Content
   ```

3. **Однина для колекцій:**
   ```
   ❌ /api/task
   ❌ /api/user
   ✅ /api/tasks
   ✅ /api/users
   ```

4. **Один DTO для всього:**
   ```
   ❌ Один TaskDTO для create/update/response
   ✅ CreateTaskDTO, UpdateTaskDTO, TaskResponse
   ```

5. **Відсутність обґрунтування:**
   ```
   ❌ Просто таблиця без пояснень
   ✅ Таблиця + пояснення чому саме так
   ```

✅ **Робіть так:**

- Іменники у множині для ресурсів.
- Правильні HTTP методи для операцій.
- Різні DTO для різних операцій.
- Стандартизовані помилки з кодами.
- ISO 8601 для дат.
- Обґрунтовуйте свої рішення.
- Думайте про реальне використання API.

---

## Приклад виконання (інша предметна область)

### Система управління бібліотекою

Для допомоги розумінню, наведено приклад для ІНШОЇ предметної області.

#### 1. Аналіз предметної області

| Ресурс | Основні атрибути | Типи даних |
|--------|------------------|------------|
| Book | id, title, author, isbn, available, publishedYear | UUID, string, string, string, boolean, integer |
| Reader | id, name, email, registeredAt | UUID, string, string, datetime |

**Обов'язкові поля:**

- Book: title, author, isbn
- Reader: name, email

**Автоматично згенеровані:**

- id (обидва ресурси)
- registeredAt (Reader)
- available (Book, за замовчуванням true)

#### 2. Кінцеві точки API (endpoints)

| HTTP метод | Шлях URI | Опис | Статус-коди |
|------------|----------|------|-------------|
| GET | /api/books | Список всіх книг | 200, 401 |
| GET | /api/books/{id} | Конкретна книга | 200, 404, 401 |
| POST | /api/books | Додати нову книгу | 201, 400, 401, 409 |
| PUT | /api/books/{id} | Оновити дані книги | 200, 400, 404, 401 |
| DELETE | /api/books/{id} | Видалити книгу | 204, 404, 401 |
| GET | /api/books?available=true | Фільтр: доступні книги | 200, 401 |
| GET | /api/readers | Список читачів | 200, 401 |
| GET | /api/readers/{id} | Конкретний читач | 200, 404, 401 |

**Приклади фільтрації:**
```
GET /api/books?available=true
GET /api/books?author=Шевченко&publishedYear=2020
```

**Обґрунтування:**

- Використовуємо RESTful конвенції: іменники у множині (/books, /readers).
- GET для читання - безпечний та ідемпотентний.
- POST для створення - повертає 201 Created з Location header.
- DELETE повертає 204 No Content, бо немає тіла відповіді.
- 404 коли ресурс не існує, 400 при некоректних даних.
- Фільтрація через query parameters - стандартний підхід.

#### 3. Структури даних

**Book ResponseDTO:**
```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "title": "Кобзар",
  "author": "Тарас Шевченко",
  "isbn": "978-966-03-4385-8",
  "available": true,
  "publishedYear": 1840
}
```

**CreateBookDTO:**
```json
{
  "title": "Кобзар",
  "author": "Тарас Шевченко",
  "isbn": "978-966-03-4385-8",
  "publishedYear": 1840
}
```

**Пояснення:** Клієнт не надсилає id (генерується сервером) та available (за замовчуванням true).

**UpdateBookDTO:**
```json
{
  "title": "Кобзар (повне видання)",
  "available": false
}
```

**Пояснення:** Всі поля необов'язкові - можна оновити тільки те, що потрібно.

**Список книг:**
```json
{
  "data": [
    {
      "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "title": "Кобзар",
      "author": "Тарас Шевченко",
      "isbn": "978-966-03-4385-8",
      "available": true,
      "publishedYear": 1840
    },
    {
      "id": "b2c3d4e5-f6a7-8901-bcde-f12345678901",
      "title": "Тіні забутих предків",
      "author": "Михайло Коцюбинський",
      "isbn": "978-966-10-0256-4",
      "available": false,
      "publishedYear": 1911
    }
  ],
  "total": 42,
  "page": 1,
  "limit": 20
}
```

#### 4. Обробка помилок

**Стандартна структура:**
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Зрозуміле користувачу повідомлення",
    "timestamp": "2025-10-22T14:30:00Z"
  }
}
```

**Приклад - книга з таким ISBN вже існує:**
```json
{
  "error": {
    "code": "RESOURCE_CONFLICT",
    "message": "Книга з ISBN '978-966-03-4385-8' вже існує в системі",
    "timestamp": "2025-10-22T14:30:00Z"
  }
}
```
*HTTP статус: 409 Conflict*

**Приклад - валідація:**
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Некоректні дані",
    "details": [
      {
        "field": "isbn",
        "message": "ISBN має бути у форматі 978-X-XXX-XXXXX-X"
      },
      {
        "field": "publishedYear",
        "message": "Рік видання має бути між 1000 та 2025"
      }
    ],
    "timestamp": "2025-10-22T14:30:00Z"
  }
}
```
*HTTP статус: 400 Bad Request*

---

**Зверніть увагу:** Це приклад для ІНШОЇ системи (бібліотека), а не для вашого завдання (управління задачами). Використовуйте його як орієнтир для структури та стилю, але розробіть власне рішення!

---

## Додаткові ресурси

1. **RFC 7231** - HTTP/1.1 Semantics
2. **REST API Tutorial** - https://restfulapi.net/
3. **OpenAPI Specification** - https://swagger.io/specification/
4. **Richardson Maturity Model** - https://martinfowler.com/articles/richardsonMaturityModel.html
5. **HTTP Status Codes** - https://httpstatuses.com/
