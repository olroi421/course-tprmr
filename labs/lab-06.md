# Лабораторна робота 6 Контейнеризація застосунку з Docker

## Мета

Набути практичних навичок контейнеризації FastAPI-додатків з використанням Docker, навчитися створювати багатоконтейнерні середовища з Docker Compose, опанувати основи управління конфігурацією через змінні оточення.

## Завдання

Створити повноцінне контейнеризоване середовище для FastAPI-додатка, що включає вебсервер та базу даних PostgreSQL. Налаштувати взаємодію між контейнерами, управління конфігурацією через змінні оточення та персистентність даних.

## Теоретичні відомості

### Docker та контейнеризація

Docker є платформою для розробки, доставки та запуску додатків у контейнерах. Контейнер являє собою стандартизовану одиницю програмного забезпечення, що пакує код та всі його залежності, забезпечуючи швидкий та надійний запуск додатка в різних обчислювальних середовищах.

Основні переваги контейнеризації включають ізоляцію додатків, портативність між різними середовищами, ефективне використання ресурсів порівняно з віртуальними машинами, швидке розгортання та масштабування. Docker використовує образи як шаблони лише для читання, що містять інструкції для створення контейнерів. Контейнери є запущеними екземплярами образів, що виконуються як ізольовані процеси.

### Dockerfile

Dockerfile є текстовим документом, що містить набір інструкцій для автоматизованої побудови Docker-образу. Кожна інструкція у Dockerfile створює новий шар в образі, що дозволяє ефективно кешувати та повторно використовувати незмінні частини.

Основні інструкції Dockerfile включають FROM для визначення базового образу, WORKDIR для встановлення робочої директорії, COPY для копіювання файлів з хост-системи в образ, RUN для виконання команд під час побудови образу, EXPOSE для документування портів, що прослуховує додаток, та CMD для визначення команди запуску контейнера.

### Docker Compose

Docker Compose є інструментом для визначення та запуску багатоконтейнерних Docker-додатків. Конфігурація описується у YAML-файлі, що дозволяє декларативно визначити всі сервіси, мережі та томи додатка.

Compose забезпечує управління життєвим циклом додатка через прості команди, автоматичне створення мереж для взаємодії контейнерів, управління залежностями між сервісами та можливість масштабування сервісів. Файл docker-compose.yml визначає версію специфікації, сервіси з їх конфігурацією, мережі для зв'язку між контейнерами та томи для персистентності даних.

### Змінні оточення та конфігурація

Змінні оточення є ключовим механізмом для управління конфігурацією контейнеризованих додатків. Вони дозволяють відокремити конфігурацію від коду, забезпечуючи гнучкість розгортання в різних середовищах без зміни образу.

Файл .env використовується для зберігання змінних оточення у форматі ключ-значення. Docker Compose автоматично завантажує змінні з цього файлу. Важливо не включати .env файли до системи контролю версій, оскільки вони містять конфіденційну інформацію.

### Мережі Docker

Docker автоматично створює мережу для сервісів, визначених у docker-compose.yml. Контейнери в одній мережі можуть взаємодіяти один з одним, використовуючи імена сервісів як DNS-імена. Це значно спрощує налаштування зв'язку між сервісами без необхідності знати IP-адреси контейнерів.

### Томи Docker

Томи є рекомендованим механізмом для персистентності даних у Docker. Вони існують незалежно від життєвого циклу контейнерів, що дозволяє зберігати дані навіть після видалення контейнера. Томи керуються Docker і можуть ефективно спільно використовуватися між контейнерами.

### Багатоетапна побудова образів

Багатоетапна побудова дозволяє створювати оптимізовані образи шляхом використання кількох інструкцій FROM у одному Dockerfile. Це дозволяє відокремити етап збірки від кінцевого образу, зменшуючи його розмір та поверхню атаки.

## Хід роботи

### Підготовка проєкту

Створіть структуру проєкту для контейнеризації існуючого FastAPI-додатка з підтримкою бази даних PostgreSQL та базовим CRUD-функціоналом. Переконайтеся, що ваш проєкт має файл requirements.txt з необхідними залежностями.

### Створення Dockerfile

Створіть файл Dockerfile у кореневій директорії проєкту з наступною структурою. Використайте офіційний образ Python як базовий, встановіть робочу директорію, скопіюйте файл залежностей та встановіть їх. Після цього скопіюйте код додатка, відкрийте необхідний порт та визначте команду запуску через uvicorn.

Оптимізуйте Dockerfile, розміщуючи інструкції копіювання requirements.txt перед копіюванням всього коду для ефективного кешування шарів. Додайте налаштування для роботи з змінними оточення.

### Налаштування змінних оточення

Створіть файл .env у кореневій директорії проєкту для зберігання конфігураційних параметрів. Визначте змінні для параметрів бази даних, включаючи тип бази даних, користувача, пароль, хост, порт та назву бази. Додайте URL підключення до бази даних у форматі, що використовується SQLAlchemy.

Створіть файл .env.example з шаблоном змінних без реальних значень для документування необхідних налаштувань. Додайте .env до файлу .gitignore для запобігання витоку конфіденційної інформації.

### Адаптація коду додатка

Модифікуйте код вашого FastAPI-додатка для читання конфігурації зі змінних оточення. Використовуйте бібліотеку python-decouple або стандартний модуль os для доступу до змінних оточення. Переконайтеся, що рядок підключення до бази даних формується динамічно на основі змінних оточення.

### Створення Docker Compose конфігурації

Створіть файл docker-compose.yml у кореневій директорії проєкту. Визначте два сервіси: один для FastAPI-додатка та один для бази даних PostgreSQL. Налаштуйте залежності між сервісами, вказавши, що API-сервіс залежить від сервісу бази даних.

Для сервісу бази даних використайте офіційний образ PostgreSQL, передайте змінні оточення для налаштування бази, створіть том для персистентності даних та відкрийте порт для можливості підключення ззовні під час розробки.

Для API-сервісу вкажіть побудову образу з поточної директорії, передайте необхідні змінні оточення, прив'яжіть порт контейнера до порту хоста та налаштуйте автоматичний перезапуск контейнера.

### Побудова та запуск контейнерів

Виконайте побудову образів командою docker-compose build. Переконайтеся, що побудова завершилася успішно без помилок. Запустіть контейнери в фоновому режимі командою docker-compose up з відповідним прапором.

Перевірте статус запущених контейнерів командою docker-compose ps. Переглядайте логи сервісів для діагностики можливих проблем. Відкрийте браузер та перейдіть до документації API за адресою localhost з вказаним портом та шляхом до docs.

### Тестування взаємодії сервісів

Протестуйте роботу API через інтерактивну документацію Swagger UI. Виконайте операції створення, читання, оновлення та видалення записів через API endpoints. Переконайтеся, що дані зберігаються в базі даних PostgreSQL.

Перевірте персистентність даних, зупинивши контейнери командою docker-compose down без видалення томів, а потім знову запустивши їх. Дані повинні залишитися збереженими.

### Робота з контейнерами

Навчіться виконувати команди всередині запущених контейнерів. Підключіться до контейнера бази даних та виконайте SQL-запити для перевірки структури та вмісту таблиць. Перегляньте логи окремих сервісів для моніторингу їх роботи.

### Оптимізація та документація

Додайте файл .dockerignore для виключення непотрібних файлів з образу, таких як віртуальне оточення Python, кеш-файли, файли git та інше. Це зменшить розмір образу та прискорить побудову.

Створіть докладний звіт у файлі README.md з повною документацією виконаної роботи. Включіть опис проєкту, структуру файлів, інструкції щодо розгортання, скріншоти роботи додатка, API документації, виконання CRUD-операцій, статусу контейнерів та результатів тестування персистентності даних.

## Критерії оцінювання

Максимальна оцінка за лабораторну роботу становить 7 балів.

**Dockerfile (1 бал):** створено коректний Dockerfile з використанням офіційного образу Python, правильним встановленням залежностей, копіюванням коду додатка та налаштуванням команди запуску. Образ успішно будується без помилок.

**Docker Compose конфігурація (1 бал):** створено файл docker-compose.yml з налаштуванням двох сервісів (FastAPI та PostgreSQL), правильними залежностями між ними, налаштуванням портів та базовою конфігурацією змінних оточення.

**Управління змінними оточення (1 бал):** створено .env файл з конфігураційними параметрами, .env.example як шаблон, .env додано до .gitignore. Код додатка адаптовано для читання конфігурації зі змінних оточення.

**Персистентність даних (1 бал):** налаштовано томи Docker для збереження даних PostgreSQL. Продемонстровано, що дані зберігаються після перезапуску контейнерів. CRUD-операції працюють коректно з базою даних.

**Оптимізація та best practices (1 бал):** створено .dockerignore для оптимізації образу, використано кешування шарів у Dockerfile через правильний порядок інструкцій, налаштовано health checks або restart policies для сервісів.

**Функціональність API (1 бал):** FastAPI-додаток успішно запускається в контейнері, доступний через браузер, інтерактивна документація Swagger UI працює коректно, всі CRUD-операції виконуються без помилок.

**Звіт у README.md з документацією (1 бал):** створено докладний звіт, що містить опис проєкту та його структуру, інструкції з налаштування змінних оточення, команди для побудови та запуску контейнерів, скріншоти запущених контейнерів, скріншоти API документації та виконання операцій, скріншоти перевірки персистентності даних, посилання на репозиторій GitHub із повним кодом проєкту.

## Форма здачі

Здача лабораторної роботи здійснюється через Moodle шляхом надання посилання на публічний GitHub репозиторій. Репозиторій повинен містити весь код проєкту, Dockerfile, docker-compose.yml, .env.example, .dockerignore, .gitignore та докладний звіт у файлі README.md зі скріншотами виконання всіх етапів роботи.

## Контрольні запитання

1. Які основні переваги контейнеризації додатків порівняно з традиційним розгортанням? Як Docker забезпечує ізоляцію процесів?

2. Поясніть призначення кожної інструкції у Dockerfile та чому важливий порядок їх розміщення для ефективного кешування.

3. Як Docker Compose спрощує управління багатоконтейнерними додатками? Яка роль файлу docker-compose.yml?

4. Чому важливо використовувати змінні оточення для конфігурації додатків? Які ризики пов'язані з хардкодингом конфігурації?

5. Як контейнери в Docker Compose взаємодіють між собою через мережу? Що використовується для DNS-резолюції?

6. Яка різниця між томами Docker та bind mounts? Коли варто використовувати кожен з цих підходів?

7. Що таке багатоетапна побудова Docker образів і як вона допомагає оптимізувати розмір кінцевого образу?
